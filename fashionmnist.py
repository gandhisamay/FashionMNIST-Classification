# -*- coding: utf-8 -*-
"""FashionMNIST.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Rh2jfEZvecCtzZhnNTR0p4sPBk_X58pu
"""

from google.colab import drive 
drive.mount('drive')

import torch
import torch.nn as nn 
import matplotlib.pyplot as plt

from torchvision import transforms
transform = transforms.Compose([transforms.ToTensor(),
                                 transforms.Normalize(0.5,0.5)])

from torchvision import datasets

data_path = '/content/drive/MyDrive/Datasets '
train_dataset = datasets.FashionMNIST(data_path , download = False,train = True,transform = transform)
test_dataset = datasets.FashionMNIST(data_path , download = False, train = False,transform = transform)

#-----Viewing Image-----#
imgs = next(iter(train_dataset))
plt.axis('off')
plt.title('Fashion MNIST')
plt.tight_layout()
plt.imshow(imgs[0][0], cmap ='gray')

from torch.utils.data import DataLoader
batch_size = 128 
train_loader = DataLoader(train_dataset,batch_size)
test_loader = DataLoader(test_dataset, batch_size*2)

class Classifier(nn.Module):
  def __init__(self,input_channels,numchannelslayer1, numchannelslayer2,imgheight,imgwidth,fclayer1size,fclayer2size):
    '''input_channels : Number of channels in input images
       numchannelslayer1 : Number of channels after passing through first Convulation layer
       numchannelslayer1 : Number of channels after passing through second Convulation layer
       imgheight : Height of input image 
       imgwidth  : Width of input image 
       fclayer1size : Layer size of the first fully connected layer
       fclayer2size : Layer size of the second fully connected layer'''

    super().__init__()
    self.input_channels = input_channels
    self.numchannelslayer1 = numchannelslayer1
    self.numchannelslayer2 = numchannelslayer2
    self.height = imgheight
    self.width  = imgwidth
    self.fclayer1size = fclayer1size
    self.fclayer2size = fclayer2size

    self.conv1 = nn.Conv2d(self.input_channels,self.numchannelslayer1,kernel_size = 3, padding = 1)
    self.pool1 = nn.MaxPool2d(2)
    self.act1  = nn.ReLU()

    self.conv2 = nn.Conv2d(self.numchannelslayer1, self.numchannelslayer2, kernel_size = 3, padding = 1)
    self.pool2 = nn.MaxPool2d(2)
    self.act2  = nn.ReLU()
     
    self.height1 = int(self.height/4)
    self.width1 = int(self.width/4)

    self.fc1   = nn.Linear(self.numchannelslayer2*self.height1*self.width1,self.fclayer1size)
    self.act3  = nn.ReLU()

    self.fc2   = nn.Linear(self.fclayer1size, self.fclayer2size)
    self.act4  = nn.Tanh()

  def forward(self,x):
    out = self.act1(self.pool1(self.conv1(x)))
    out = self.act2(self.pool2(self.conv2(out)))
    out = out.view(-1,self.numchannelslayer2*self.height1*self.width1)
    out = self.act3(self.fc1(out))
    out = self.act4(self.fc2(out))
    return out

  def CorrectPredictions(self,out,y):
    labels = torch.argmax(out,axis = 1)
    correct = (labels == y).sum()
    return correct

model = Classifier(input_channels = 1 ,numchannelslayer1 = 16, numchannelslayer2 = 32,imgheight = 28,imgwidth = 28,fclayer1size = 256,fclayer2size = 10)
model.to('cuda')

loss_fn = nn.CrossEntropyLoss()
opt = torch.optim.SGD(model.parameters(), lr = 1e-1)

num_epochs = 50
iters = [i for i in range(num_epochs)]
lossperepoch = []
model.train()
for epochs in range(1,num_epochs+1):
  loss_total = 0.0
  correct_total = 0
  for imgs,labels in train_loader:
    imgs,labels = imgs.to('cuda'),labels.to('cuda')
    outputs = model(imgs)

    loss = loss_fn(outputs,labels)

    loss.backward()

    opt.step()
    opt.zero_grad()

    loss_total += loss

    correct = model.CorrectPredictions(outputs,labels)
    correct_total += correct

  lossperepoch.append(loss_total)

  print("[{}/{}] Accuracy: {}%".format(epochs,num_epochs,float(correct_total/len(train_dataset)*100)))

#-----Graph between loss and epochs----#
plt.title('Loss with iterations')
plt.xlabel('Iterations')
plt.ylabel('Loss')
plt.style.use('seaborn')
plt.tight_layout()
plt.plot(lossperepoch,iters)

model.eval()

#Checking model performance on test set
correct_total_test = 0 
total = 0 

for imgs, labels in test_loader:
  imgs , labels = imgs.to('cuda'),labels.to('cuda')
  test_outputs = model(imgs)
  correct_test = (torch.argmax(test_outputs, axis = 1) == labels).sum()
  correct_total_test += correct_test
  total += labels.shape[0]
print('Accuracy : {}%'.format(float(correct_total_test/total)*100))

"""Training set accuaracy : 94.61 %
Test set accuracy : 91.09 %
"""